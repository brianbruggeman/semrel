use std::collections::HashMap;
use std::path::{Path, PathBuf};

use git2::{Oid, TreeWalkMode};

use super::CommitInfo;
use crate::{BumpRule, CommitType, ConventionalCommit, RepositoryError, SimpleVersion, SupportedManifest};

pub struct ChangeLog {
    pub current_version: SimpleVersion,
    pub changes: Vec<CommitInfo>,
}

impl ChangeLog {
    pub fn new(current_version: impl Into<SimpleVersion>, changes: impl AsRef<[CommitInfo]>) -> Self {
        Self {
            current_version: current_version.into(),
            changes: changes.as_ref().to_owned(),
        }
    }

    pub fn next_version(&self, rules: &[(CommitType, BumpRule)]) -> SimpleVersion {
        let rules = rules.to_vec();
        let version = self.current_version;
        let max_bump = self
            .changes
            .iter()
            .fold(BumpRule::default(), |max_bump, commit| max_bump.max(commit.rule(&rules)));
        version.bump(max_bump)
    }

    /// Generates a release notes for the changelog
    ///
    /// The release notes are generated by organizing the commits into sections based on the commit type
    /// and scope.  Within each scoped section, the commit messages are listed in reverse chronological order.
    ///
    /// # Example
    /// ```markdown
    /// # Release notes: (v1.0.0) - 2021-01-01
    /// ## Breaking Changes
    /// ## Features
    /// ### <scope>
    /// - <commit message>
    /// - <commit message>
    /// - <commit message>
    /// ## Fixes
    /// - Others
    /// ```
    pub fn release_notes(&self, rules: &[(CommitType, BumpRule)]) -> String {
        let aggregated_commits = self.aggregated_commits();
        let today = chrono::Local::now();
        let mut notes = format!("# Release notes: {} ({})\n", self.next_version(rules), today.format("%Y-%m-%d"));
        for (commit_type, scopes) in aggregated_commits {
            notes.push_str(&format!("\n\n## {}\n", commit_type.as_release_note()));
            for (scope, commits) in scopes {
                if !scope.is_empty() {
                    notes.push_str(&format!("\n### {}\n", scope));
                }
                for commit in commits {
                    notes.push_str(&format!("- {}\n", commit.commit.subject));
                }
            }
        }
        notes
    }

    pub fn aggregated_commits(&self) -> Vec<(CommitType, Vec<(String, Vec<CommitInfo>)>)> {
        let mut map: HashMap<CommitType, HashMap<String, Vec<CommitInfo>>> = HashMap::new();
        for commit_info in &self.changes {
            let commit_type = commit_info.commit.commit_type.clone();
            let scope = commit_info.commit.scope.clone().unwrap_or_default();
            let entry = map.entry(commit_type).or_default();
            let scope = entry.entry(scope).or_default();
            scope.push(commit_info.clone());
        }
        let mut vec: Vec<(CommitType, Vec<(String, Vec<CommitInfo>)>)> = map
            .into_iter()
            .map(|(commit_type, scopes)| (commit_type, scopes.into_iter().collect()))
            .collect();
        vec.sort();
        vec
    }
}

/// Generates a changelog for the commit
///
/// This requires going back to the previous bump level and collecting all commits up since that point.
///   - For patches, this is just going back to the previous patch bump
///   - For minors, this is going back to the previous minor bump which includes all patches since then
///   - For majors, this is going back to the previous major bump which includes all minors and patches since then
///
///
pub fn get_changelog(repo: &git2::Repository, rules: &[(CommitType, BumpRule)]) -> Result<ChangeLog, RepositoryError> {
    let repo_path = repo.path().parent().unwrap().to_path_buf();
    tracing::debug!("Starting get_changelog for path: {}", repo_path.display());
    let manifest = SupportedManifest::try_from(repo_path.clone()).map_err(|err| {
        tracing::error!("Failed to get manifest: {err}");
        err
    })?;
    let filename: PathBuf = manifest.filename()?.into();
    tracing::debug!("Manifest filename: {}", filename.display());
    let current_version = manifest.version()?;
    tracing::debug!("Current version: {}", current_version);
    let mut max_bump = BumpRule::default();
    let commits = revwalk_commit_log(repo)?;
    // first we need to collect all of the commits for this version
    let mut captured_commits = vec![];
    let rules = rules.to_vec();
    for commit_info in commits {
        let bump_rule = commit_info.rule(&rules);
        if bump_rule > max_bump {
            max_bump = bump_rule;
        }
        let mut capture = true;
        let oid = Oid::from_str(&commit_info.id).map_err(|_| RepositoryError::InvalidRepositoryPath(PathBuf::from(&commit_info.id)))?;
        let commit = repo
            .find_commit(oid)
            .map_err(|_| RepositoryError::CommitNotFound(oid.to_string()))?;
        let files = commit_info
            .files
            .iter()
            .map(|file| file.file_name().unwrap().to_str().unwrap())
            .collect::<Vec<_>>();
        let path = files.iter().find(|f| **f == filename.file_name().unwrap().to_str().unwrap());
        if let Some(path) = path {
            let data = load_file_data(repo, &commit, path)?;
            let previous_version = SupportedManifest::parse(path, &data)?.version()?;
            if previous_version < current_version {
                // Only include commits that are part of the previous bump at the same level
                match (bump_rule, previous_version.minor(), previous_version.patch()) {
                    (BumpRule::Major, 0, 0) => capture = false,
                    (BumpRule::Minor, _p_min, 0) => capture = false,
                    (BumpRule::Patch, _p_min, _p_pat) => capture = false,
                    _ => {}
                }
            }
            if !capture {
                break;
            }
        } else {
            let data = load_file_data(repo, &commit, filename.clone())?;
            let previous_version = SupportedManifest::parse(filename.clone(), &data)?.version()?;
            if previous_version < current_version {
                // So when the current commit is the one that's updated the version, we want to exclude it
                if captured_commits.len() == 1 {
                    captured_commits.clear();
                }
                break;
            }
        }
        if capture {
            captured_commits.push(commit_info);
        }
    }
    let changelog = ChangeLog::new(current_version, captured_commits);
    tracing::debug!("Finished get_changelog");
    Ok(changelog)
}

/// Retrieves the data of a file in a specific commit
///
/// # Arguments
///
/// * `repo` - A reference to the repository
/// * `commit` - The commit to retrieve the file data from
/// * `path` - The path of the file in the repository
///
/// # Returns
///
/// * `Result<String, RepositoryError>` - The file data as a string if successful, or an error
fn load_file_data(repo: &git2::Repository, commit: &git2::Commit, path: impl AsRef<Path>) -> Result<String, RepositoryError> {
    let path = path.as_ref();
    let oid = commit.id();
    tracing::debug!("Loading file data for path: {} using commit id: {}", path.display(), oid);
    let tree = commit
        .tree()
        .map_err(|_| RepositoryError::CommitTreeError(commit.id().to_string()))?;
    let entry = tree
        .get_path(path)
        .map_err(|why| RepositoryError::FileNotFound(path.to_str().unwrap().to_string(), why.to_string()))?;
    let blob = repo
        .find_blob(entry.id())
        .map_err(|why| RepositoryError::BlobNotFound(entry.id().to_string(), why.to_string()))?;
    let content = std::str::from_utf8(blob.content()).map_err(|why| RepositoryError::BlobToTextError(entry.id().to_string(), why.to_string()))?;
    tracing::debug!("Successfully loaded file data for path: {}", path.display());
    Ok(content.to_string())
}

/// Generates a changelog as an iterator of commit information
///
/// This has no filter but simply returns all commits in the repository converted from oid to commit information
/// As an iterator, this is a lazy eval.  We do not want to capture the entire commit history in memory
#[allow(clippy::needless_lifetimes)]
pub fn revwalk_commit_log<'a>(repo: &'a git2::Repository) -> Result<impl IntoIterator<Item = CommitInfo> + 'a, RepositoryError> {
    let walker = revwalk(repo)?;
    let data = walker.into_iter().flat_map(|oid| {
        let commit = repo
            .find_commit(oid)
            .map_err(|_| RepositoryError::CommitNotFound(oid.to_string()))?;
        let conventional_commit = ConventionalCommit::try_from(commit.message().unwrap_or_default())?;
        let files_changed = get_files_changed(repo, oid)?;
        let timestamp = commit.time().seconds();
        let timestamp = num_traits::cast::<i64, u64>(timestamp).unwrap();
        let info = CommitInfo::new(oid.to_string(), files_changed, conventional_commit, timestamp);
        Ok::<CommitInfo, RepositoryError>(info)
    });
    Ok(data)
}

/// Retrieves the files changed in a commit
fn get_files_changed(repo: &git2::Repository, oid: impl Into<git2::Oid>) -> Result<Vec<PathBuf>, RepositoryError> {
    let oid = oid.into();
    let commit = repo
        .find_commit(oid)
        .map_err(|_| RepositoryError::CommitNotFound(oid.to_string()))?;
    let tree = commit.tree().map_err(|why| RepositoryError::CommitTreeError(why.to_string()))?;
    let mut files = vec![];
    // If the commit has a parent, compare it to the parent's tree
    if let Some(parent_commit) = commit.parents().next() {
        let parent_tree = parent_commit
            .tree()
            .map_err(|why| RepositoryError::CommitTreeError(why.to_string()))?;
        let diff = repo
            .diff_tree_to_tree(Some(&parent_tree), Some(&tree), None)
            .map_err(|why| RepositoryError::CommitDiffError(why.to_string()))?;

        diff.foreach(
            &mut |delta, _| {
                if let Some(path) = delta.new_file().path() {
                    files.push(path.to_path_buf());
                }
                true
            },
            None,
            None,
            None,
        )
        .map_err(|why| RepositoryError::CommitDiffError(why.to_string()))?;
    } else {
        // If there's no parent, this is the initial commit
        // We consider all files in the initial commit as "changed"
        tree.walk(TreeWalkMode::PreOrder, |_, entry| {
            if let Some(name) = entry.name() {
                files.push(PathBuf::from(name));
            }
            0
        })
        .map_err(|why| RepositoryError::CommitTreeError(why.to_string()))?;
    }
    Ok(files)
}

/// Generates an iterator that walks the repository in reverse order
#[allow(clippy::needless_lifetimes)]
pub fn revwalk<'a>(repo: &'a git2::Repository) -> Result<impl IntoIterator<Item = Oid> + 'a, RepositoryError> {
    let repo = Box::leak(Box::new(repo));
    let mut revwalk = repo.revwalk().map_err(|why| {
        tracing::error!("Failed to create revwalk: {why}");
        RepositoryError::InvalidRepository(why.to_string())
    })?;
    // Push the head of the repository to the revwalk, otherwise it has no where to start
    revwalk.push_head().map_err(|why| {
        tracing::error!("Failed to push head: {why}");
        RepositoryError::InvalidRepository(why.to_string())
    })?;
    Ok(revwalk.flat_map(move |oid| match oid {
        Ok(oid) => Ok(oid),
        Err(why) => {
            tracing::error!("Failed to get oid: {why}");
            Err(RepositoryError::InvalidRepository(why.to_string()))
        }
    }))
}

#[cfg(test)]
mod tests {
    use super::*;

    use git2::{Oid, Repository, Signature};
    use tempfile::TempDir;

    struct TestRepo {
        temp_dir: TempDir,
        repo: Repository,
    }

    impl TestRepo {
        fn new() -> Self {
            let temp_dir = TempDir::new().unwrap();
            let temp_path = temp_dir.path().join("repo");
            let repo = Repository::init(&temp_path).unwrap();
            TestRepo { temp_dir, repo }
        }

        fn path(&self) -> PathBuf {
            self.temp_dir.path().join("repo")
        }

        fn commit(&self, message: &str) -> Result<Oid, RepositoryError> {
            let sig = Signature::now("Test", "test@example.com").unwrap();
            let tree_id = {
                let mut index = self
                    .repo
                    .index()
                    .map_err(|_| RepositoryError::InvalidRepositoryPath(self.path().to_path_buf()))?;
                index
                    .write_tree()
                    .map_err(|_| RepositoryError::InvalidRepositoryPath(self.path().to_path_buf()))?
            };
            let tree = self
                .repo
                .find_tree(tree_id)
                .map_err(|_| RepositoryError::InvalidRepositoryPath(self.path().to_path_buf()))?;
            let parent_commit = self
                .repo
                .head()
                .ok()
                .and_then(|h| h.target())
                .and_then(|t| self.repo.find_commit(t).ok());
            let parents = parent_commit.as_ref().map(|p| vec![p]).unwrap_or_else(Vec::new);
            self.repo
                .commit(Some("HEAD"), &sig, &sig, message, &tree, &parents)
                .map_err(|_| RepositoryError::InvalidRepositoryPath(self.path().to_path_buf()))
        }

        fn add_file(&self, path: &str, content: &str) -> Result<(), RepositoryError> {
            use std::fs::File;
            use std::io::Write;
            let file_path = self.path().join(path);
            let mut file = File::create(&file_path).unwrap();
            file.write_all(content.as_bytes()).unwrap();

            let mut index = self.repo.index().unwrap();
            index.add_path(Path::new(path)).unwrap();
            index.write().unwrap();

            Ok(())
        }
    }

    #[test]
    fn case_empty() {
        let test_repo = TestRepo::new();
        let result = revwalk(&test_repo.repo);
        assert!(result.is_err(), "Expected an error for an empty repository");
    }

    #[test]
    fn case_single_commit() {
        let test_repo = TestRepo::new();
        test_repo.commit("Initial commit").expect("Failed to commit");
        let result: Vec<Oid> = revwalk(&test_repo.repo).expect("Could not revwalk").into_iter().collect();
        assert_eq!(result.len(), 1, "Expected one commit in the revwalk");
    }

    #[test]
    fn case_multiple_commits() {
        let test_repo = TestRepo::new();
        test_repo.commit("Initial commit").expect("Failed to commit");
        let result: Vec<Oid> = revwalk(&test_repo.repo).expect("Could not revwalk").into_iter().collect();
        assert_eq!(result.len(), 1, "Expected two commits in the revwalk");
        test_repo.commit("Another commit").expect("Failed to commit");
        let result: Vec<Oid> = revwalk(&test_repo.repo).expect("Could not revwalk").into_iter().collect();
        assert_eq!(result.len(), 2, "Expected two commits in the revwalk");
    }

    #[test]
    fn case_iter_interface() {
        let test_repo = TestRepo::new();
        test_repo.commit("Initial commit").expect("Failed to commit");
        test_repo.commit("Another commit").expect("Failed to commit");
        let mut walker = revwalk(&test_repo.repo).expect("Could not revwalk").into_iter();
        let mut counter = 0;
        while let Some(_oid) = walker.next() {
            counter += 1;
        }
        assert_eq!(counter, 2, "Expected two commits in the revwalk");
    }

    #[test]
    fn test_get_files_changed_empty() {
        let test_repo = TestRepo::new();
        let commit_oid = test_repo.commit("Initial commit").expect("Failed to commit");
        let result = get_files_changed(&test_repo.repo, commit_oid).expect("Failed to get files changed");
        assert_eq!(result.len(), 0, "Expected no files changed in the initial commit");
    }

    #[test]
    fn test_get_files_changed_single_file() {
        let test_repo = TestRepo::new();
        test_repo.add_file("test.txt", "Hello, world!").expect("Failed to add file");
        let commit_oid = test_repo.commit("Add test.txt").expect("Failed to commit");
        let result = get_files_changed(&test_repo.repo, commit_oid).expect("Failed to get files changed");
        assert_eq!(result.len(), 1, "Expected one file changed");
        assert_eq!(result[0].to_str().unwrap(), "test.txt", "Expected test.txt to be changed");
    }

    #[test]
    fn test_get_files_changed_multiple_files() {
        let test_repo = TestRepo::new();
        test_repo.add_file("test1.txt", "Hello, world!").expect("Failed to add file");
        test_repo.add_file("test2.txt", "Hello, world!").expect("Failed to add file");
        let commit_oid = test_repo.commit("Add test1.txt and test2.txt").expect("Failed to commit");
        let result = get_files_changed(&test_repo.repo, commit_oid).expect("Failed to get files changed");
        assert_eq!(result.len(), 2, "Expected two files changed");
        let filenames: Vec<_> = result.iter().map(|path| path.to_str().unwrap()).collect();
        assert!(filenames.contains(&"test1.txt"), "Expected test1.txt to be changed");
        assert!(filenames.contains(&"test2.txt"), "Expected test2.txt to be changed");
    }

    #[test]
    fn test_get_commit_log() {
        let test_repo = TestRepo::new();
        test_repo.add_file("file1.txt", "Hello, world!").expect("Failed to add file");
        test_repo.commit("Add file1.txt").unwrap();
        test_repo.add_file("file2.txt", "Hello, again!").expect("Failed to add file");
        test_repo.commit("Add file2.txt").unwrap();

        let commit_log = revwalk_commit_log(&test_repo.repo).unwrap();
        let commits: Vec<_> = commit_log.into_iter().collect();

        assert_eq!(commits.len(), 2);
        assert_eq!(commits[0].commit.message(), "Add file2.txt");
        assert_eq!(commits[1].commit.message(), "Add file1.txt");
    }
}
