use std::collections::HashMap;
use std::path::{Path, PathBuf};

use git2::{Oid, TreeWalkMode};

use super::CommitInfo;
use crate::{find_top_of_repo, BumpRule, CommitType, ConventionalCommit, RepositoryError, SimpleVersion, SupportedManifest};

#[derive(Debug, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub struct CommitGroup {
    commit_type: CommitType,
    scopes: Vec<(String, Vec<CommitInfo>)>,
}

impl CommitGroup {
    pub fn new(commit_type: CommitType, scopes: Vec<(String, Vec<CommitInfo>)>) -> Self {
        Self { commit_type, scopes }
    }
}

pub struct ChangeLog {
    pub current_version: SimpleVersion,
    pub changes: Vec<CommitInfo>,
}

impl ChangeLog {
    pub fn new(current_version: impl Into<SimpleVersion>, changes: impl AsRef<[CommitInfo]>) -> Self {
        Self {
            current_version: current_version.into(),
            changes: changes.as_ref().to_owned(),
        }
    }

    pub fn next_version(&self, rules: &[(CommitType, BumpRule)]) -> SimpleVersion {
        let rules = rules.to_vec();
        let version = self.current_version;
        let max_bump = self
            .changes
            .iter()
            .fold(BumpRule::default(), |max_bump, commit| max_bump.max(commit.rule(&rules)));
        version.bump(max_bump)
    }

    /// Generates a release notes for the changelog
    ///
    /// The release notes are generated by organizing the commits into sections based on the commit type
    /// and scope.  Within each scoped section, the commit messages are listed in reverse chronological order.
    ///
    /// # Example
    /// ```markdown
    /// # Release notes: (v1.0.0) - 2021-01-01
    /// ## Breaking Changes
    /// ## Features
    /// ### <scope>
    /// - <commit message>
    /// - <commit message>
    /// - <commit message>
    /// ## Fixes
    /// - Others
    /// ```
    pub fn release_notes(&self, rules: &[(CommitType, BumpRule)]) -> String {
        let aggregated_commits = self.aggregated_commits();
        let today = chrono::Local::now();
        let mut notes = format!("# Release notes: {} ({})\n", self.next_version(rules), today.format("%Y-%m-%d"));
        for commit_group in aggregated_commits {
            notes.push_str(&format!("\n\n## {}\n", commit_group.commit_type.as_release_note()));
            for (scope, commits) in commit_group.scopes {
                if !scope.is_empty() {
                    notes.push_str(&format!("\n### {}\n", scope));
                }
                for commit in commits {
                    if commit.commit_type().as_str().starts_with("semrel") {
                        continue;
                    }
                    notes.push_str(&format!("- {}\n", commit.commit.subject));
                }
            }
        }
        notes
    }

    pub fn aggregated_commits(&self) -> Vec<CommitGroup> {
        let mut map: HashMap<CommitType, HashMap<String, Vec<CommitInfo>>> = HashMap::new();
        for commit_info in &self.changes {
            let commit_type = commit_info.commit.commit_type.clone();
            let scope = commit_info.commit.scope.clone().unwrap_or_default();
            let entry = map.entry(commit_type).or_default();
            let scope = entry.entry(scope).or_default();
            scope.push(commit_info.clone());
        }
        let mut vec: Vec<CommitGroup> = map
            .into_iter()
            .map(|(commit_type, scopes)| CommitGroup::new(commit_type, scopes.into_iter().collect()))
            .collect();
        vec.sort();
        vec
    }
}

/// Generates a changelog for the commit
///
/// This requires going back to the previous bump level and collecting all commits up since that point.
///   - For patches, this is just going back to the previous patch bump
///   - For minors, this is going back to the previous minor bump which includes all patches since then
///   - For majors, this is going back to the previous major bump which includes all minors and patches since then
///
///
pub fn get_changelog(repo: &git2::Repository, manifest_path: impl Into<PathBuf>, rules: &[(CommitType, BumpRule)]) -> Result<ChangeLog, RepositoryError> {
    let manifest_path = manifest_path.into();
    tracing::trace!("Getting changelog for manifest path: {}", manifest_path.display());
    let project_path = manifest_path.parent().unwrap();
    tracing::trace!("Getting changelog for project path: {}", project_path.display());
    let repo_path = find_top_of_repo(project_path)?;
    let project_path = Box::leak(Box::new({
        let project_path = project_path.canonicalize().unwrap();
        if project_path.is_dir() {
            project_path.canonicalize().unwrap()
        } else {
            project_path.parent().unwrap().canonicalize().unwrap().to_path_buf()
        }
    }));
    let relative_manifest_path = {
        let new_path = compute_relative_path(&repo_path, &manifest_path);
        match new_path.starts_with("./") {
            true => new_path.strip_prefix("./").unwrap().to_path_buf(),
            false => new_path,
        }
    };
    tracing::trace!("Searching for relative manifest path: {}", relative_manifest_path.display());
    let relative_project_path = compute_relative_path(&repo_path, project_path);
    tracing::debug!("Starting get_changelog for path: {}", relative_project_path.display());
    let manifest = SupportedManifest::try_from(manifest_path.to_owned()).map_err(|err| {
        tracing::error!("Failed to get manifest: {err}");
        err
    })?;
    let current_version = manifest.version()?;
    tracing::debug!("Current version: {}", current_version);
    let mut max_bump = BumpRule::default();
    let commits = revwalk_commit_log(repo, &manifest_path)?;
    // first we need to collect all of the commits for this version
    let mut captured_commits = vec![];
    let rules = rules.to_vec();
    for commit_info in commits {
        let mut capture = true;
        let oid = Oid::from_str(&commit_info.id).map_err(|_| RepositoryError::InvalidRepositoryPath(PathBuf::from(&commit_info.id)))?;
        let commit = repo
            .find_commit(oid)
            .map_err(|_| RepositoryError::CommitNotFound(oid.to_string()))?;
        tracing::trace!("Found commit: {commit:?}");
        if let Some(path) = commit_info
            .files
            .iter()
            .inspect(|f| {
                tracing::trace!("Looking for manifest file [{oid}]: {} =? {}", f.display(), relative_manifest_path.display());
            })
            .find(|f| *f == &relative_manifest_path)
        {
            tracing::debug!("Manifest file found: {}", path.display());
            let data = load_file_data(repo, &commit, path)?;
            let previous_version = SupportedManifest::parse(path, &data)?.version()?;
            if previous_version < current_version {
                let bump_rule = commit_info.rule(&rules);
                if bump_rule > max_bump {
                    tracing::debug!("New max bump: {:?} from commit: {} {}", bump_rule, commit_info.id, commit_info.message());
                    max_bump = bump_rule;
                }
                // Only include commits that are part of the previous bump at the same level
                match (bump_rule, previous_version.minor(), previous_version.patch()) {
                    (BumpRule::Major, 0, 0) => {
                        tracing::debug!("Stopped at major: {}", commit_info.id);
                        capture = false
                    }
                    (BumpRule::Minor, _p_min, 0) => {
                        tracing::debug!("Stopped at minor: {}", commit_info.id);
                        capture = false
                    }
                    (BumpRule::Patch, _p_min, _p_pat) => {
                        tracing::debug!("Stopped at patch: {}", commit_info.id);
                        capture = false
                    }
                    _ => {}
                }
            }
            if !capture {
                tracing::debug!("Stopped at commit: {}", commit_info.message());
                break;
            }
        } else {
            tracing::debug!("No manifest updates found in commit.");
            let data = load_file_data(repo, &commit, &relative_manifest_path)?;
            let previous_version = SupportedManifest::parse(relative_manifest_path.clone(), &data)?.version()?;
            if previous_version < current_version {
                // So when the current commit is the one that's updated the version, we want to exclude it
                if captured_commits.len() == 1 {
                    captured_commits.clear();
                }
                break;
            }
        }
        if capture {
            tracing::debug!("Including commit: {} {}", commit_info.id, commit_info.message());
            captured_commits.push(commit_info);
        }
    }
    let changelog = ChangeLog::new(current_version, captured_commits);
    tracing::debug!("Finished get_changelog. Current version: {} Max bump: {:?}", current_version, max_bump);
    Ok(changelog)
}

/// Retrieves the data of a file in a specific commit
///
/// # Arguments
///
/// * `repo` - A reference to the repository
/// * `commit` - The commit to retrieve the file data from
/// * `path` - The path of the file in the repository
///
/// # Returns
///
/// * `Result<String, RepositoryError>` - The file data as a string if successful, or an error
fn load_file_data(repo: &git2::Repository, commit: &git2::Commit, path: impl AsRef<Path>) -> Result<String, RepositoryError> {
    let path = path.as_ref();
    let oid = commit.id();
    tracing::trace!("Loading file data for path: {} using commit id: {}", path.display(), oid);
    let tree = commit
        .tree()
        .map_err(|_| RepositoryError::CommitTreeError(commit.id().to_string()))?;
    let entry = tree
        .get_path(path)
        .map_err(|why| RepositoryError::FileNotFound(path.to_str().unwrap().to_string(), why.to_string()))?;
    let blob = repo
        .find_blob(entry.id())
        .map_err(|why| RepositoryError::BlobNotFound(entry.id().to_string(), why.to_string()))?;
    let content = std::str::from_utf8(blob.content()).map_err(|why| RepositoryError::BlobToTextError(entry.id().to_string(), why.to_string()))?;
    tracing::trace!("Successfully loaded file data for path: {}", path.display());
    Ok(content.to_string())
}

/// Generates a changelog as an iterator of commit information
///
/// This has no filter but simply returns all commits in the repository converted from oid to commit information
/// As an iterator, this is a lazy eval.  We do not want to capture the entire commit history in memory
#[allow(clippy::needless_lifetimes)]
pub fn revwalk_commit_log<'a>(repo: &'a git2::Repository, project_path: impl Into<PathBuf>) -> Result<impl IntoIterator<Item = CommitInfo> + 'a, RepositoryError> {
    let walker = revwalk(repo, project_path)?;
    let data = walker.into_iter().flat_map(|oid| {
        let commit = repo
            .find_commit(oid)
            .map_err(|_| RepositoryError::CommitNotFound(oid.to_string()))?;
        let conventional_commit = ConventionalCommit::try_from(commit.message().unwrap_or_default())?;
        let files_changed = get_files_changed(repo, oid)?;
        let timestamp = commit.time().seconds();
        let timestamp = num_traits::cast::<i64, u64>(timestamp).unwrap();
        let info: CommitInfo = CommitInfo::new(oid.to_string(), files_changed, conventional_commit, timestamp);
        Ok::<CommitInfo, RepositoryError>(info)
    });
    Ok(data)
}

/// Retrieves the files changed in a commit
fn get_files_changed(repo: &git2::Repository, oid: impl Into<git2::Oid>) -> Result<Vec<PathBuf>, RepositoryError> {
    let oid = oid.into();
    let commit = repo
        .find_commit(oid)
        .map_err(|_| RepositoryError::CommitNotFound(oid.to_string()))?;
    let tree = commit.tree().map_err(|why| RepositoryError::CommitTreeError(why.to_string()))?;
    let mut files = vec![];
    // If the commit has a parent, compare it to the parent's tree
    if let Some(parent_commit) = commit.parents().next() {
        let parent_tree = parent_commit
            .tree()
            .map_err(|why| RepositoryError::CommitTreeError(why.to_string()))?;
        let diff = repo
            .diff_tree_to_tree(Some(&parent_tree), Some(&tree), None)
            .map_err(|why| RepositoryError::CommitDiffError(why.to_string()))?;

        diff.foreach(
            &mut |delta, _| {
                if let Some(path) = delta.new_file().path() {
                    files.push(path.to_path_buf());
                }
                true
            },
            None,
            None,
            None,
        )
        .map_err(|why| RepositoryError::CommitDiffError(why.to_string()))?;
    } else {
        // If there's no parent, this is the initial commit
        // We consider all files in the initial commit as "changed"
        tree.walk(TreeWalkMode::PreOrder, |_, entry| {
            if let Some(name) = entry.name() {
                files.push(PathBuf::from(name));
            }
            0
        })
        .map_err(|why| RepositoryError::CommitTreeError(why.to_string()))?;
    }
    Ok(files)
}

/// Generates an iterator that walks the repository in reverse order
#[allow(clippy::needless_lifetimes)]
pub fn revwalk<'a>(repo: &'a git2::Repository, project_path: impl Into<PathBuf>) -> Result<impl IntoIterator<Item = Oid> + 'a, RepositoryError> {
    let repo = Box::leak(Box::new(repo));
    let project_path = project_path.into();
    let repo_path = find_top_of_repo(&project_path)?;
    let project_path = Box::leak(Box::new({
        let project_path = project_path.canonicalize().unwrap();
        if project_path.is_dir() {
            project_path.canonicalize().unwrap()
        } else {
            project_path.parent().unwrap().canonicalize().unwrap().to_path_buf()
        }
    }));

    let mut revwalk = repo.revwalk().map_err(|why| {
        tracing::error!("Failed to create revwalk: {why}");
        RepositoryError::InvalidRepository(why.to_string())
    })?;
    // Push the head of the repository to the revwalk, otherwise it has no where to start
    revwalk.push_head().map_err(|why| {
        tracing::error!("Failed to push head: {why}");
        RepositoryError::InvalidRepository(why.to_string())
    })?;

    // Set time as sorter
    revwalk.set_sorting(git2::Sort::TIME).map_err(|why| {
        tracing::error!("Failed to push head: {why}");
        RepositoryError::InvalidRepository(why.to_string())
    })?;

    // Return all of the oids, but filter on the project files
    //  This is preliminary support for multi-package/monorepos
    #[allow(clippy::needless_borrows_for_generic_args)]
    let data = revwalk
        .flat_map(|oid| oid.map_err(|why| RepositoryError::InvalidRepository(why.to_string())))
        .flat_map::<Result<(Oid, Vec<PathBuf>), RepositoryError>, _>(|oid| {
            let files_changed = get_files_changed(repo, oid)?;
            Ok((oid, files_changed))
        })
        .filter_map(move |(oid, files)| match files.is_empty() {
            true => None,
            false => match files
                .iter()
                .filter_map(|file| match repo_path.join(file).starts_with(&project_path) {
                    true => Some(repo_path.join(file)),
                    false => None,
                })
                .any(|file| file.starts_with(&project_path))
            {
                true => Some(oid),
                false => None,
            },
        });
    Ok(data.into_iter())
}

fn compute_relative_path(repo_path: impl AsRef<Path>, project_path: impl AsRef<Path>) -> PathBuf {
    let repo_path = repo_path.as_ref();
    let project_path = project_path.as_ref();
    let mut relative_path = PathBuf::new();
    let mut repo_components = repo_path.components();
    let mut project_components = project_path.components();

    // Find the common prefix
    let mut index = 0;
    loop {
        match (repo_components.next(), project_components.next()) {
            (Some(repo_comp), Some(project_comp)) if repo_comp == project_comp => {
                index += 1;
            }
            _ => break,
        }
    }

    // If there is no common prefix, return project_path
    if index == 0 {
        return project_path.to_path_buf();
    }

    // Determine the number of components to pop from repo_path
    let mut repo_components = repo_path.components();
    for _ in 0..index {
        repo_components.next();
    }
    for _ in repo_components {
        relative_path.push("..");
    }

    // Add the remaining components of project_path
    let mut project_components = project_path.components();
    for _ in 0..index {
        project_components.next();
    }
    for component in project_components {
        relative_path.push(component.as_os_str());
    }

    relative_path
}

// fn compute_relative_path(repo_path: &Path, project_path: &Path) -> PathBuf {
//     let mut relative_path = PathBuf::new();
//     let repo_count = repo_path.components().count();
//     let path_count = project_path.components().count();
//     let mut index = 0;
//     for (repo_comp, project_comp) in repo_path.components().zip(project_path.components()) {
//         if repo_comp != project_comp {
//             break;
//         }
//         index += 1;
//     }

//     if index == 0 {
//         project_path.to_path_buf()
//     } else {
//         if index == repo_count && index == path_count {
//             return PathBuf::new();
//         }

//         let uncommon_components = project_path
//             .components()
//             .skip(index)
//             .map(|c| c.as_os_str().to_str().unwrap())
//             .collect::<Vec<_>>();
//         relative_path.push(uncommon_components.join("/"));
//         relative_path
//     }
// }

#[cfg(test)]
mod tests {
    use super::*;

    use git2::{Oid, Repository, Signature};
    use rstest::rstest;
    use tempfile::TempDir;

    struct TestRepo {
        temp_dir: TempDir,
        repo: Repository,
    }

    impl TestRepo {
        fn new() -> Self {
            // Default behavior is to setup tracing to error if the RUST_LOG variable is not set
            //  This code will only setup tracing if the RUST_LOG variable is set
            if std::env::var("RUST_LOG").is_ok() {
                tracing_subscriber::fmt()
                    .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
                    .try_init()
                    .ok();
            }
            let temp_dir = TempDir::new().unwrap();
            let temp_path = temp_dir.path().join("repo");
            let repo = Repository::init(&temp_path).unwrap();
            TestRepo { temp_dir, repo }
        }

        fn path(&self) -> PathBuf {
            self.temp_dir.path().join("repo")
        }

        fn commit(&self, message: &str) -> Result<Oid, RepositoryError> {
            let sig = Signature::now("Test", "test@example.com").unwrap();
            let tree_id = {
                let mut index = self
                    .repo
                    .index()
                    .map_err(|_| RepositoryError::InvalidRepositoryPath(self.path().to_path_buf()))?;
                index
                    .write_tree()
                    .map_err(|_| RepositoryError::InvalidRepositoryPath(self.path().to_path_buf()))?
            };
            let tree = self
                .repo
                .find_tree(tree_id)
                .map_err(|_| RepositoryError::InvalidRepositoryPath(self.path().to_path_buf()))?;
            let parent_commit = self
                .repo
                .head()
                .ok()
                .and_then(|h| h.target())
                .and_then(|t| self.repo.find_commit(t).ok());
            let parents = parent_commit.as_ref().map(|p| vec![p]).unwrap_or_default();
            self.repo
                .commit(Some("HEAD"), &sig, &sig, message, &tree, &parents)
                .map_err(|_| RepositoryError::InvalidRepositoryPath(self.path().to_path_buf()))
        }

        fn add_file(&self, path: &str, content: &str) -> Result<(), RepositoryError> {
            use std::fs::File;
            use std::io::Write;
            let file_path = self.path().join(path);
            let mut file = File::create(&file_path).unwrap();
            file.write_all(content.as_bytes()).unwrap();

            let mut index = self.repo.index().unwrap();
            index.add_path(Path::new(path)).unwrap();
            index.write().unwrap();

            Ok(())
        }
    }

    #[test]
    fn case_empty() {
        let test_repo = TestRepo::new();
        let result = revwalk(&test_repo.repo, test_repo.path());
        assert!(result.is_err(), "Expected an error for an empty repository");
    }

    #[test]
    fn case_single_commit() {
        let test_repo = TestRepo::new();
        test_repo.commit("Initial commit").expect("Failed to commit");
        let result: Vec<Oid> = revwalk(&test_repo.repo, test_repo.path())
            .expect("Could not revwalk")
            .into_iter()
            .collect();
        assert_eq!(result.len(), 0, "Expected no commits in the revwalk");
    }

    #[test]
    fn case_multiple_commits() {
        let test_repo = TestRepo::new();
        test_repo.commit("Initial commit").expect("Failed to commit");
        let result: Vec<Oid> = revwalk(&test_repo.repo, test_repo.path())
            .expect("Could not revwalk")
            .into_iter()
            .collect();
        assert_eq!(result.len(), 0, "Expected no commits in the revwalk");
        test_repo.commit("Another commit").expect("Failed to commit");
        let result: Vec<Oid> = revwalk(&test_repo.repo, test_repo.path())
            .expect("Could not revwalk")
            .into_iter()
            .collect();
        assert_eq!(result.len(), 0, "Expected no commits in the revwalk");
    }

    #[test]
    fn case_iter_interface() {
        let test_repo = TestRepo::new();
        test_repo.commit("Initial commit").expect("Failed to commit");
        test_repo.commit("Another commit").expect("Failed to commit");
        let walker = revwalk(&test_repo.repo, test_repo.path())
            .expect("Could not revwalk")
            .into_iter();
        let mut counter = 0;
        for _oid in walker {
            counter += 1;
        }
        assert_eq!(counter, 0, "Expected no commits in the revwalk, because no files");
    }

    #[test]
    fn test_get_files_changed_empty() {
        let test_repo = TestRepo::new();
        let commit_oid = test_repo.commit("Initial commit").expect("Failed to commit");
        let result = get_files_changed(&test_repo.repo, commit_oid).expect("Failed to get files changed");
        assert_eq!(result.len(), 0, "Expected no files changed in the initial commit");
    }

    #[test]
    fn test_get_files_changed_single_file() {
        let test_repo = TestRepo::new();
        test_repo.add_file("test.txt", "Hello, world!").expect("Failed to add file");
        let commit_oid = test_repo.commit("Add test.txt").expect("Failed to commit");
        let result = get_files_changed(&test_repo.repo, commit_oid).expect("Failed to get files changed");
        assert_eq!(result.len(), 1, "Expected one file changed");
        assert_eq!(result[0].to_str().unwrap(), "test.txt", "Expected test.txt to be changed");
    }

    #[test]
    fn test_get_files_changed_multiple_files() {
        let test_repo = TestRepo::new();
        test_repo.add_file("test1.txt", "Hello, world!").expect("Failed to add file");
        test_repo.add_file("test2.txt", "Hello, world!").expect("Failed to add file");
        let commit_oid = test_repo.commit("Add test1.txt and test2.txt").expect("Failed to commit");
        let result = get_files_changed(&test_repo.repo, commit_oid).expect("Failed to get files changed");
        assert_eq!(result.len(), 2, "Expected two files changed");
        let filenames: Vec<_> = result.iter().map(|path| path.to_str().unwrap()).collect();
        assert!(filenames.contains(&"test1.txt"), "Expected test1.txt to be changed");
        assert!(filenames.contains(&"test2.txt"), "Expected test2.txt to be changed");
    }

    #[test]
    fn test_get_commit_log() {
        let test_repo = TestRepo::new();
        test_repo.add_file("file1.txt", "Hello, world!").expect("Failed to add file");
        test_repo.commit("Add file1.txt").unwrap();
        test_repo.add_file("file2.txt", "Hello, again!").expect("Failed to add file");
        test_repo.commit("Add file2.txt").unwrap();
        let path = test_repo.path();

        let commit_log = revwalk_commit_log(&test_repo.repo, path).unwrap();
        let commits: Vec<_> = commit_log.into_iter().collect();

        assert_eq!(commits.len(), 2);
        assert_eq!(commits[0].commit.message(), "Add file2.txt");
        assert_eq!(commits[1].commit.message(), "Add file1.txt");
    }

    #[rstest]
    #[case::empty_empty("", "", "")]
    #[case::empty_root("", "/root", "/root")]
    #[case::root_empty("/root", "", "")]
    #[case::initial_overlap_extra_project("/root/path", "/root/path/to/file", "to/file")]
    #[case::initial_overlap_extra_root("/root/path/to/file", "/root/path", "../../")]
    #[case::cargo_toml("/root/path", "/root/path/Cargo.toml", "Cargo.toml")]
    fn test_relative_path(#[case] repo_path: &str, #[case] project_path: &str, #[case] expected: &str) {
        let repo_path = Path::new(repo_path);
        let project_path = Path::new(project_path);
        let expected = Path::new(expected);
        let result = compute_relative_path(repo_path, project_path);
        assert_eq!(result, expected);
    }
}
