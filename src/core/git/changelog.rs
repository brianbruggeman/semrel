use std::collections::HashMap;
use std::path::{Path, PathBuf};

use git2::{Oid, TreeWalkMode};

use super::CommitInfo;
use crate::{find_top_of_repo, BumpRule, CommitType, ConventionalCommit, RepositoryError, SimpleVersion, SupportedManifest};

#[derive(Debug, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub struct CommitGroup {
    commit_type: CommitType,
    scopes: Vec<(String, Vec<CommitInfo>)>,
}

impl CommitGroup {
    pub fn new(commit_type: CommitType, scopes: Vec<(String, Vec<CommitInfo>)>) -> Self {
        Self { commit_type, scopes }
    }
}

pub struct ChangeLog {
    pub current_version: SimpleVersion,
    pub changes: Vec<CommitInfo>,
}

impl ChangeLog {
    pub fn new(current_version: impl Into<SimpleVersion>, changes: impl AsRef<[CommitInfo]>) -> Self {
        Self {
            current_version: current_version.into(),
            changes: changes.as_ref().to_owned(),
        }
    }

    pub fn next_version(&self, rules: &[(CommitType, BumpRule)]) -> SimpleVersion {
        let rules = rules.to_vec();
        let version = self.current_version;
        let max_bump = self
            .changes
            .iter()
            .fold(BumpRule::default(), |max_bump, commit| max_bump.max(commit.rule(&rules)));
        version.bump(max_bump)
    }

    /// Generates a release notes for the changelog
    ///
    /// The release notes are generated by organizing the commits into sections based on the commit type
    /// and scope.  Within each scoped section, the commit messages are listed in reverse chronological order.
    ///
    /// # Example
    /// ```markdown
    /// # Release notes: (v1.0.0) - 2021-01-01
    /// ## Breaking Changes
    /// ## Features
    /// ### <scope>
    /// - <commit message>
    /// - <commit message>
    /// - <commit message>
    /// ## Fixes
    /// - Others
    /// ```
    pub fn release_notes(&self, rules: &[(CommitType, BumpRule)]) -> String {
        let aggregated_commits = self.aggregated_commits();
        let today = chrono::Local::now();
        let mut notes = format!("# Release notes: {} ({})\n", self.next_version(rules), today.format("%Y-%m-%d"));
        for commit_group in aggregated_commits {
            notes.push_str(&format!("\n\n## {}\n", commit_group.commit_type.as_release_note()));
            for (scope, commits) in commit_group.scopes {
                if !scope.is_empty() {
                    notes.push_str(&format!("\n### {}\n", scope));
                }
                for commit in commits {
                    if commit.commit_type().as_str().starts_with("semrel") {
                        continue;
                    }
                    notes.push_str(&format!("- {}\n", commit.commit.subject));
                }
            }
        }
        notes
    }

    pub fn aggregated_commits(&self) -> Vec<CommitGroup> {
        let mut map: HashMap<CommitType, HashMap<String, Vec<CommitInfo>>> = HashMap::new();
        for commit_info in &self.changes {
            let commit_type = commit_info.commit.commit_type.clone();
            let scope = commit_info.commit.scope.clone().unwrap_or_default();
            let entry = map.entry(commit_type).or_default();
            let scope = entry.entry(scope).or_default();
            scope.push(commit_info.clone());
        }
        let ignored = ["semrel"];
        let mut vec: Vec<CommitGroup> = map
            .into_iter()
            .filter(|(commit_type, _)| !ignored.iter().any(|s| commit_type.as_str().starts_with(s)))
            .map(|(commit_type, scopes)| CommitGroup::new(commit_type, scopes.into_iter().collect()))
            .inspect(|group| println!("Commit group: {group:?}"))
            .collect();
        vec.sort();
        vec
    }
}

/// Generates a changelog for the commit
///
/// This requires going back to the previous bump level and collecting all commits up since that point.
///   - For patches, this is just going back to the previous patch bump
///   - For minors, this is going back to the previous minor bump which includes all patches since then
///   - For majors, this is going back to the previous major bump which includes all minors and patches since then
///
///
pub fn get_changelog(repo: &git2::Repository, manifest_path: impl Into<PathBuf>, rules: &[(CommitType, BumpRule)]) -> Result<ChangeLog, RepositoryError> {
    let manifest_path = manifest_path.into();
    tracing::trace!("Getting changelog for manifest path: {}", manifest_path.display());
    let project_path = manifest_path.parent().unwrap();
    tracing::trace!("Getting changelog for project path: {}", project_path.display());
    let repo_path = find_top_of_repo(project_path)?;
    let project_path = Box::leak(Box::new({
        let project_path = project_path.canonicalize().unwrap();
        if project_path.is_dir() {
            project_path.canonicalize().unwrap()
        } else {
            project_path.parent().unwrap().canonicalize().unwrap().to_path_buf()
        }
    }));
    let relative_manifest_path = {
        let new_path = compute_relative_path(&repo_path, &manifest_path);
        match new_path.starts_with("./") {
            true => new_path.strip_prefix("./").unwrap().to_path_buf(),
            false => new_path,
        }
    };
    tracing::trace!("Searching for relative manifest path: {}", relative_manifest_path.display());
    let relative_project_path = compute_relative_path(&repo_path, project_path);
    tracing::debug!("Starting get_changelog for path: {}", relative_project_path.display());
    let manifest = SupportedManifest::try_from(manifest_path.to_owned()).map_err(|err| {
        tracing::error!("Failed to get manifest: {err}");
        err
    })?;
    let current_version = manifest.version()?;
    tracing::debug!("Current version: {}", current_version);
    let mut max_bump = BumpRule::default();
    let commits = revwalk_commit_log(repo, &manifest_path)?;
    // first we need to collect all of the commits for this version
    let mut captured_commits = vec![];
    let rules = rules.to_vec();
    for commit_info in commits {
        let mut capture = true;
        let oid = Oid::from_str(&commit_info.id).map_err(|_| RepositoryError::InvalidRepositoryPath(PathBuf::from(&commit_info.id)))?;
        let commit = repo
            .find_commit(oid)
            .map_err(|_| RepositoryError::CommitNotFound(oid.to_string()))?;
        tracing::trace!("Found commit: {commit:?}");
        if let Some(path) = commit_info
            .files
            .iter()
            .inspect(|f| {
                tracing::trace!("Looking for manifest file [{oid}]: {} =? {}", f.display(), relative_manifest_path.display());
            })
            .find(|f| *f == &relative_manifest_path)
        {
            tracing::debug!("Manifest file found: {}", path.display());
            let data = load_file_data(repo, &commit, path)?;
            let previous_version = SupportedManifest::parse(path, &data)?.version()?;
            if previous_version < current_version {
                let bump_rule = commit_info.rule(&rules);
                if bump_rule > max_bump {
                    tracing::debug!("New max bump: {:?} from commit: {} {}", bump_rule, commit_info.id, commit_info.message());
                    max_bump = bump_rule;
                }
                // Only include commits that are part of the previous bump at the same level
                match (bump_rule, previous_version.minor(), previous_version.patch()) {
                    (BumpRule::Major, 0, 0) => {
                        tracing::debug!("Stopped at major: {}", commit_info.id);
                        capture = false
                    }
                    (BumpRule::Minor, _p_min, 0) => {
                        tracing::debug!("Stopped at minor: {}", commit_info.id);
                        capture = false
                    }
                    (BumpRule::Patch, _p_min, _p_pat) => {
                        tracing::debug!("Stopped at patch: {}", commit_info.id);
                        capture = false
                    }
                    _ => {}
                }
            }
            if !capture {
                tracing::debug!("Stopped at commit: {}", commit_info.message());
                break;
            }
        } else {
            tracing::debug!("No manifest updates found in commit.");
            let data = load_file_data(repo, &commit, &relative_manifest_path)?;
            let previous_version = SupportedManifest::parse(relative_manifest_path.clone(), &data)?.version()?;
            if previous_version < current_version {
                // So when the current commit is the one that's updated the version, we want to exclude it
                if captured_commits.len() == 1 {
                    captured_commits.clear();
                }
                break;
            }
        }
        if capture {
            tracing::debug!("Including commit: {} {}", commit_info.id, commit_info.message());
            captured_commits.push(commit_info);
        }
    }
    let changelog = ChangeLog::new(current_version, captured_commits);
    tracing::debug!("Finished get_changelog. Current version: {} Max bump: {:?}", current_version, max_bump);
    Ok(changelog)
}

/// Retrieves the data of a file in a specific commit
///
/// # Arguments
///
/// * `repo` - A reference to the repository
/// * `commit` - The commit to retrieve the file data from
/// * `path` - The path of the file in the repository
///
/// # Returns
///
/// * `Result<String, RepositoryError>` - The file data as a string if successful, or an error
fn load_file_data(repo: &git2::Repository, commit: &git2::Commit, path: impl AsRef<Path>) -> Result<String, RepositoryError> {
    let path = path.as_ref();
    let oid = commit.id();
    tracing::trace!("Loading file data for path: {} using commit id: {}", path.display(), oid);
    let tree = commit
        .tree()
        .map_err(|_| RepositoryError::CommitTreeError(commit.id().to_string()))?;
    let entry = tree
        .get_path(path)
        .map_err(|why| RepositoryError::FileNotFound(path.to_str().unwrap().to_string(), why.to_string()))?;
    let blob = repo
        .find_blob(entry.id())
        .map_err(|why| RepositoryError::BlobNotFound(entry.id().to_string(), why.to_string()))?;
    let content = std::str::from_utf8(blob.content()).map_err(|why| RepositoryError::BlobToTextError(entry.id().to_string(), why.to_string()))?;
    tracing::trace!("Successfully loaded file data for path: {}", path.display());
    Ok(content.to_string())
}

/// Generates a changelog as an iterator of commit information
///
/// This has no filter but simply returns all commits in the repository converted from oid to commit information
/// As an iterator, this is a lazy eval.  We do not want to capture the entire commit history in memory
#[allow(clippy::needless_lifetimes)]
pub fn revwalk_commit_log<'a>(repo: &'a git2::Repository, project_path: impl Into<PathBuf>) -> Result<impl IntoIterator<Item = CommitInfo> + 'a, RepositoryError> {
    let walker = revwalk(repo, project_path)?;
    let data = walker.into_iter().flat_map(|oid| {
        let commit = repo
            .find_commit(oid)
            .map_err(|_| RepositoryError::CommitNotFound(oid.to_string()))?;
        let conventional_commit = ConventionalCommit::try_from(commit.message().unwrap_or_default())?;
        let files_changed = get_files_changed(repo, oid)?;
        let timestamp = commit.time().seconds();
        let timestamp = num_traits::cast::<i64, u64>(timestamp).unwrap();
        let info: CommitInfo = CommitInfo::new(oid.to_string(), files_changed, conventional_commit, timestamp);
        Ok::<CommitInfo, RepositoryError>(info)
    });
    Ok(data)
}

/// Retrieves the files changed in a commit
fn get_files_changed(repo: &git2::Repository, oid: impl Into<git2::Oid>) -> Result<Vec<PathBuf>, RepositoryError> {
    let oid = oid.into();
    let commit = repo
        .find_commit(oid)
        .map_err(|_| RepositoryError::CommitNotFound(oid.to_string()))?;
    let tree = commit.tree().map_err(|why| RepositoryError::CommitTreeError(why.to_string()))?;
    let mut files = vec![];
    // If the commit has a parent, compare it to the parent's tree
    if let Some(parent_commit) = commit.parents().next() {
        let parent_tree = parent_commit
            .tree()
            .map_err(|why| RepositoryError::CommitTreeError(why.to_string()))?;
        let diff = repo
            .diff_tree_to_tree(Some(&parent_tree), Some(&tree), None)
            .map_err(|why| RepositoryError::CommitDiffError(why.to_string()))?;

        diff.foreach(
            &mut |delta, _| {
                if let Some(path) = delta.new_file().path() {
                    files.push(path.to_path_buf());
                }
                true
            },
            None,
            None,
            None,
        )
        .map_err(|why| RepositoryError::CommitDiffError(why.to_string()))?;
    } else {
        // If there's no parent, this is the initial commit
        // We consider all files in the initial commit as "changed"
        tree.walk(TreeWalkMode::PreOrder, |_, entry| {
            if let Some(name) = entry.name() {
                files.push(PathBuf::from(name));
            }
            0
        })
        .map_err(|why| RepositoryError::CommitTreeError(why.to_string()))?;
    }
    Ok(files)
}

/// Generates an iterator that walks the repository in reverse order
#[allow(clippy::needless_lifetimes)]
pub fn revwalk<'a>(repo: &'a git2::Repository, project_path: impl Into<PathBuf>) -> Result<impl IntoIterator<Item = Oid> + 'a, RepositoryError> {
    let repo = Box::leak(Box::new(repo));
    let project_path = project_path.into();
    let repo_path = find_top_of_repo(&project_path)?;
    let project_path = Box::leak(Box::new({
        let project_path = project_path.canonicalize().unwrap();
        if project_path.is_dir() {
            project_path.canonicalize().unwrap()
        } else {
            project_path.parent().unwrap().canonicalize().unwrap().to_path_buf()
        }
    }));

    let mut revwalk = repo.revwalk().map_err(|why| {
        tracing::error!("Failed to create revwalk: {why}");
        RepositoryError::InvalidRepository(why.to_string())
    })?;
    // Push the head of the repository to the revwalk, otherwise it has no where to start
    revwalk.push_head().map_err(|why| {
        tracing::error!("Failed to push head: {why}");
        RepositoryError::InvalidRepository(why.to_string())
    })?;

    // Use topological sort
    revwalk.set_sorting(git2::Sort::TOPOLOGICAL).map_err(|why| {
        tracing::error!("Failed to sort repo: {why}");
        RepositoryError::InvalidRepository(why.to_string())
    })?;

    // Include merging branches
    revwalk.simplify_first_parent().map_err(|why| {
        tracing::error!("Failed to simplify: {why}");
        RepositoryError::InvalidRepository(why.to_string())
    })?;

    // Return all of the oids, but filter on the project files
    //  This is preliminary support for multi-package/monorepos
    #[allow(clippy::needless_borrows_for_generic_args)]
    let data = revwalk
        .flat_map(|oid| oid.map_err(|why| RepositoryError::InvalidRepository(why.to_string())))
        .flat_map::<Result<(Oid, Vec<PathBuf>), RepositoryError>, _>(|oid| {
            let files_changed = get_files_changed(repo, oid)?;
            Ok((oid, files_changed))
        })
        .filter_map(move |(oid, files)| match files.is_empty() {
            true => None,
            false => match files
                .iter()
                .filter_map(|file| match repo_path.join(file).starts_with(&project_path) {
                    true => Some(repo_path.join(file)),
                    false => None,
                })
                .any(|file| file.starts_with(&project_path))
            {
                true => Some(oid),
                false => None,
            },
        });
    Ok(data.into_iter())
}

fn compute_relative_path(repo_path: impl AsRef<Path>, project_path: impl AsRef<Path>) -> PathBuf {
    let repo_path = repo_path.as_ref();
    let project_path = project_path.as_ref();
    let mut relative_path = PathBuf::new();
    let mut repo_components = repo_path.components();
    let mut project_components = project_path.components();

    // Find the common prefix
    let mut index = 0;
    loop {
        match (repo_components.next(), project_components.next()) {
            (Some(repo_comp), Some(project_comp)) if repo_comp == project_comp => {
                index += 1;
            }
            _ => break,
        }
    }

    // If there is no common prefix, return project_path
    if index == 0 {
        return project_path.to_path_buf();
    }

    // Determine the number of components to pop from repo_path
    let mut repo_components = repo_path.components();
    for _ in 0..index {
        repo_components.next();
    }
    for _ in repo_components {
        relative_path.push("..");
    }

    // Add the remaining components of project_path
    let mut project_components = project_path.components();
    for _ in 0..index {
        project_components.next();
    }
    for component in project_components {
        relative_path.push(component.as_os_str());
    }

    relative_path
}

#[cfg(test)]
mod tests {
    use super::*;

    use git2::{Oid, Repository, Signature};
    use rstest::rstest;
    use tempfile::TempDir;

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum TestRepoLanguage {
        Rust,
        Python,
        JavaScript,
    }

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum TestRepoType {
        Empty,
        SingleCommit,
        MultipleCommits,
        BranchedMultipleCommits,
    }

    // Factory for building test projects
    struct TestProject<'a> {
        path: PathBuf,
        test_repo: &'a TestRepo,
        language: TestRepoLanguage,
        type_: TestRepoType,
    }

    impl<'a> TestProject<'a> {
        const FIRST_COMMIT_MESSAGE: &'static str = "First commit";

        pub fn new(path: impl AsRef<Path>, repo: &'a TestRepo, language: TestRepoLanguage, type_: TestRepoType) -> Self {
            Self {
                path: path.as_ref().to_owned(),
                test_repo: repo,
                language,
                type_,
            }
        }

        pub fn build(&self) -> Result<(), RepositoryError> {
            match self.type_ {
                TestRepoType::Empty => {}
                TestRepoType::SingleCommit => self.init()?,
                TestRepoType::MultipleCommits => {
                    self.init()?;
                    self.build_multiple_commits()?;
                }
                TestRepoType::BranchedMultipleCommits => {
                    self.init()?;
                    self.test_repo.branch("add_library")?;
                    self.build_multiple_commits()?
                }
            };
            Ok(())
        }

        fn build_multiple_commits(&self) -> Result<(), RepositoryError> {
            match self.language {
                TestRepoLanguage::Rust => self.build_multiple_commits_rust()?,
                TestRepoLanguage::Python => self.build_multiple_commits_python()?,
                TestRepoLanguage::JavaScript => self.build_multiple_commits_javascript()?,
            }
            Ok(())
        }

        fn build_multiple_commits_rust(&self) -> Result<(), RepositoryError> {
            // insert small sleep delay
            std::thread::sleep(std::time::Duration::from_millis(10));

            // Add lib.rs
            self.test_repo.add_file("lib.rs", "Hello, world!").expect("Failed to add file");
            self.test_repo.commit("fix: create library").unwrap();

            // insert small sleep delay
            std::thread::sleep(std::time::Duration::from_millis(10));

            // Update dependencies
            self.test_repo
                .add_file("foo.rs", "fn add(i: i32, j: i32) -> i32 {\n    i + j\n}")
                .expect("Failed to add file");
            self.test_repo.commit("fix: create add").unwrap();

            // Add foo.rs
            self.test_repo
                .add_file("foo.rs", "fn add(i: i32, j: i32) -> i32 {\n    i + j\n}")
                .expect("Failed to add file");
            self.test_repo.commit("fix: create add").unwrap();

            // insert small sleep delay
            std::thread::sleep(std::time::Duration::from_millis(10));

            // Update lib to include foo
            self.test_repo
                .add_file("lib.rs", "mod foo;\n\npub use foo::*;\n")
                .expect("Failed to add file");
            self.test_repo.commit("fix: use add").unwrap();

            // insert small sleep delay
            std::thread::sleep(std::time::Duration::from_millis(10));
            Ok(())
        }

        fn build_multiple_commits_python(&self) -> Result<(), RepositoryError> {
            // insert small sleep delay
            std::thread::sleep(std::time::Duration::from_millis(10));

            // Add main.py
            self.test_repo
                .add_file("main.py", "print('Hello, world!')")
                .expect("Failed to add file");
            self.test_repo.commit("fix: create library").unwrap();

            // insert small sleep delay
            std::thread::sleep(std::time::Duration::from_millis(10));

            // Add utils.py
            self.test_repo
                .add_file("utils.py", "def add(i, j):\n    return i + j")
                .expect("Failed to add file");
            self.test_repo.commit("fix: create add").unwrap();

            // insert small sleep delay
            std::thread::sleep(std::time::Duration::from_millis(10));

            // Update main.py to use utils
            self.test_repo
                .add_file("main.py", "from utils import add\n\nprint(add(1, 2))")
                .expect("Failed to add file");
            self.test_repo.commit("fix: use add").unwrap();

            // insert small sleep delay
            std::thread::sleep(std::time::Duration::from_millis(10));
            Ok(())
        }

        fn build_multiple_commits_javascript(&self) -> Result<(), RepositoryError> {
            // insert small sleep delay
            std::thread::sleep(std::time::Duration::from_millis(10));

            // Add main.js
            self.test_repo
                .add_file("main.js", "console.log('Hello, world!');")
                .expect("Failed to add file");
            self.test_repo.commit("fix: create library").unwrap();

            // insert small sleep delay
            std::thread::sleep(std::time::Duration::from_millis(10));

            // Add utils.js
            self.test_repo
                .add_file("utils.js", "function add(i, j) { return i + j; }")
                .expect("Failed to add file");
            self.test_repo.commit("fix: create add").unwrap();

            // insert small sleep delay
            std::thread::sleep(std::time::Duration::from_millis(10));

            // Update main.js to use utils
            self.test_repo
                .add_file("main.js", "const { add } = require('./utils');\n\nconsole.log(add(1, 2));")
                .expect("Failed to add file");
            self.test_repo.commit("fix: use add").unwrap();

            // insert small sleep delay
            std::thread::sleep(std::time::Duration::from_millis(10));
            Ok(())
        }

        fn generate_changelog(&self, rules: &[(CommitType, BumpRule)]) -> Result<ChangeLog, RepositoryError> {
            let manifest_path = crate::find_manifest(&self.path)?;
            get_changelog(&self.test_repo.repo, manifest_path, &rules)
        }

        fn generate_next_version(&self, rules: &[(CommitType, BumpRule)]) -> Result<SimpleVersion, RepositoryError> {
            let manifest_path = crate::find_manifest(&self.path)?;
            let changelog = get_changelog(&self.test_repo.repo, manifest_path, &rules)?;
            Ok(changelog.next_version(&rules))
        }

        fn generate_log_messages(&self, rules: &[(CommitType, BumpRule)]) -> Result<Vec<String>, RepositoryError> {
            let manifest_path = crate::find_manifest(&self.path)?;
            let changelog = get_changelog(&self.test_repo.repo, manifest_path, &rules)?;
            let log_messages = changelog.changes.iter().map(|v| v.commit.message()).collect::<Vec<_>>();
            Ok(log_messages)
        }

        fn generate_pretty_log_messages(&self, rules: &[(CommitType, BumpRule)]) -> Result<String, RepositoryError> {
            let messages = self.generate_log_messages(rules)?;
            let mut final_message = "\n".to_string();
            for (index, message) in messages.iter().enumerate() {
                final_message.push_str(&format!("{}: {}\n", index, message));
            }
            Ok(final_message)
        }

        fn init(&self) -> Result<(), RepositoryError> {
            match self.language {
                TestRepoLanguage::Rust => self.init_rust(),
                TestRepoLanguage::Python => self.init_python(),
                TestRepoLanguage::JavaScript => self.init_javascript(),
            }
        }

        fn init_rust(&self) -> Result<(), RepositoryError> {
            let cargo_toml = textwrap::dedent(
                r#"
                [package]
                name = "test"
                version = "0.1.0"
                "#,
            );
            self.test_repo.add_file("Cargo.toml", cargo_toml)?;
            self.test_repo.commit(TestProject::FIRST_COMMIT_MESSAGE)?;
            Ok(())
        }

        fn init_python(&self) -> Result<(), RepositoryError> {
            let pyproject_toml = textwrap::dedent(
                r#"
                [tool.poetry]
                name = "test"
                version = "0.1.0"
                "#,
            );
            self.test_repo.add_file("pyproject.toml", pyproject_toml)?;
            self.test_repo.commit(TestProject::FIRST_COMMIT_MESSAGE)?;
            Ok(())
        }

        fn init_javascript(&self) -> Result<(), RepositoryError> {
            let package_json = textwrap::dedent(
                r#"
                {
                    "name": "test",
                    "version": "0.1.0"
                }
                "#,
            );
            self.test_repo.add_file("package.json", package_json)?;
            self.test_repo.commit(TestProject::FIRST_COMMIT_MESSAGE)?;
            Ok(())
        }
    }

    struct TestRepo {
        temp_dir: TempDir,
        repo: Repository,
    }

    impl TestRepo {
        fn new() -> Self {
            // Default behavior is to setup tracing to error if the RUST_LOG variable is not set
            //  This code will only setup tracing if the RUST_LOG variable is set
            if std::env::var("RUST_LOG").is_ok() {
                tracing_subscriber::fmt()
                    .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
                    .try_init()
                    .ok();
            }
            let temp_dir = TempDir::new().unwrap();
            let temp_path = temp_dir.path().join("repo");
            let repo = Repository::init(&temp_path).unwrap();
            println!("Created repository here: {}", &temp_path.canonicalize().unwrap().display());
            TestRepo { temp_dir, repo }
        }

        fn path(&self) -> PathBuf {
            self.temp_dir.path().join("repo")
        }

        fn commit(&self, message: &str) -> Result<Oid, RepositoryError> {
            let sig = Signature::now("Test", "test@example.com").unwrap();
            let tree_id = {
                let mut index = self
                    .repo
                    .index()
                    .map_err(|_| RepositoryError::InvalidRepositoryPath(self.path().to_path_buf()))?;
                index
                    .write_tree()
                    .map_err(|_| RepositoryError::InvalidRepositoryPath(self.path().to_path_buf()))?
            };
            let tree = self
                .repo
                .find_tree(tree_id)
                .map_err(|_| RepositoryError::InvalidRepositoryPath(self.path().to_path_buf()))?;
            let parent_commit = self
                .repo
                .head()
                .ok()
                .and_then(|h| h.target())
                .and_then(|t| self.repo.find_commit(t).ok());
            let parents = parent_commit.as_ref().map(|p| vec![p]).unwrap_or_default();
            self.repo
                .commit(Some("HEAD"), &sig, &sig, message, &tree, &parents)
                .map_err(|_| RepositoryError::InvalidRepositoryPath(self.path().to_path_buf()))
        }

        fn add_file(&self, path: impl AsRef<Path>, content: impl AsRef<str>) -> Result<(), RepositoryError> {
            use std::fs::File;
            use std::io::Write;
            let file_path = self.path().join(path.as_ref());
            let mut file = File::create(&file_path).unwrap();
            file.write_all(content.as_ref().as_bytes()).unwrap();

            let mut index = self.repo.index().unwrap();
            index.add_path(path.as_ref()).unwrap();
            index.write_tree().unwrap();

            Ok(())
        }

        #[allow(dead_code)]
        fn branch(&self, name: impl AsRef<str>) -> Result<(), RepositoryError> {
            let branch_name = name.as_ref();
            println!("Switching to branch '{}'", branch_name); // Debug message
            match self.repo.find_branch(branch_name, git2::BranchType::Local) {
                Ok(_) => {
                    // Branch exists, so check it out
                    let obj = self.repo.revparse_single(&format!("refs/heads/{}", branch_name)).unwrap();
                    let mut checkout_builder = git2::build::CheckoutBuilder::new();
                    checkout_builder.force();
                    match self.repo.checkout_tree(&obj, None) {
                        Ok(_) => {
                            self.repo.set_head(&format!("refs/heads/{}", branch_name)).unwrap();
                            println!("Switched to existing branch '{}'", branch_name);
                        }
                        Err(why) => {
                            println!("Failed to checkout tree: {why}");
                            checkout_builder.remove_untracked(true);
                            match self.repo.checkout_tree(&obj, Some(&mut checkout_builder)) {
                                Ok(_) => {
                                    self.repo.set_head(&format!("refs/heads/{}", branch_name)).unwrap();
                                    println!("Switched to existing branch '{}'", branch_name);
                                }
                                Err(why) => {
                                    println!("Failed to checkout tree: {why}");
                                    self.repo.set_head(&format!("refs/heads/{}", branch_name)).unwrap();
                                    println!("Switched to existing branch '{}'", branch_name);
                                }
                            }
                        }
                    }
                    self.repo.set_head(&format!("refs/heads/{}", branch_name)).unwrap();
                    println!("Switched to existing branch '{}'", branch_name);
                }
                Err(_) => {
                    // Branch does not exist, so create it
                    let head_ref = self.repo.head().unwrap();
                    let head_commit = head_ref.peel_to_commit().unwrap();
                    let _branch = self.repo.branch(branch_name, &head_commit, false).unwrap();

                    // Checkout the newly created branch
                    let obj = self.repo.revparse_single(&format!("refs/heads/{}", branch_name)).unwrap();
                    let mut checkout_builder = git2::build::CheckoutBuilder::new();
                    checkout_builder.force(); // Force checkout to overcome conflicts
                    match self.repo.checkout_tree(&obj, Some(&mut checkout_builder)) {
                        Ok(_) => println!("Created and switched to new branch '{}'", branch_name),
                        Err(e) => {
                            println!("Failed to checkout tree: {e}");
                            checkout_builder.remove_untracked(true);
                            self.repo.set_head(&format!("refs/heads/{}", branch_name)).unwrap();
                            println!("Switched to existing branch '{}'", branch_name);
                        }
                    }
                    self.repo.set_head(&format!("refs/heads/{}", branch_name)).unwrap();
                }
            }

            Ok(())
        }
    }

    #[test]
    fn case_empty() {
        let test_repo = TestRepo::new();
        let result = revwalk(&test_repo.repo, test_repo.path());
        assert!(result.is_err(), "Expected an error for an empty repository");
    }

    #[test]
    fn case_single_commit() {
        let test_repo = TestRepo::new();
        test_repo.commit("Initial commit").expect("Failed to commit");
        let result: Vec<Oid> = revwalk(&test_repo.repo, test_repo.path())
            .expect("Could not revwalk")
            .into_iter()
            .collect();
        assert_eq!(result.len(), 0, "Expected no commits in the revwalk");
    }

    #[test]
    fn case_multiple_commits() {
        let test_repo = TestRepo::new();
        test_repo.commit("Initial commit").expect("Failed to commit");
        let result: Vec<Oid> = revwalk(&test_repo.repo, test_repo.path())
            .expect("Could not revwalk")
            .into_iter()
            .collect();
        assert_eq!(result.len(), 0, "Expected no commits in the revwalk");
        test_repo.commit("Another commit").expect("Failed to commit");
        let result: Vec<Oid> = revwalk(&test_repo.repo, test_repo.path())
            .expect("Could not revwalk")
            .into_iter()
            .collect();
        assert_eq!(result.len(), 0, "Expected no commits in the revwalk");
    }

    #[test]
    fn case_iter_interface() {
        let test_repo = TestRepo::new();
        test_repo.commit("Initial commit").expect("Failed to commit");
        test_repo.commit("Another commit").expect("Failed to commit");
        let walker = revwalk(&test_repo.repo, test_repo.path())
            .expect("Could not revwalk")
            .into_iter();
        let mut counter = 0;
        for _oid in walker {
            counter += 1;
        }
        assert_eq!(counter, 0, "Expected no commits in the revwalk, because no files");
    }

    #[test]
    fn test_get_files_changed_empty() {
        let test_repo = TestRepo::new();
        let commit_oid = test_repo.commit("Initial commit").expect("Failed to commit");
        let result = get_files_changed(&test_repo.repo, commit_oid).expect("Failed to get files changed");
        assert_eq!(result.len(), 0, "Expected no files changed in the initial commit");
    }

    #[test]
    fn test_get_files_changed_single_file() {
        let test_repo = TestRepo::new();
        test_repo.add_file("test.txt", "Hello, world!").expect("Failed to add file");
        let commit_oid = test_repo.commit("Add test.txt").expect("Failed to commit");
        let result = get_files_changed(&test_repo.repo, commit_oid).expect("Failed to get files changed");
        assert_eq!(result.len(), 1, "Expected one file changed");
        assert_eq!(result[0].to_str().unwrap(), "test.txt", "Expected test.txt to be changed");
    }

    #[test]
    fn test_get_files_changed_multiple_files() {
        let test_repo = TestRepo::new();
        test_repo.add_file("test1.txt", "Hello, world!").expect("Failed to add file");
        test_repo.add_file("test2.txt", "Hello, world!").expect("Failed to add file");
        let commit_oid = test_repo.commit("Add test1.txt and test2.txt").expect("Failed to commit");
        let result = get_files_changed(&test_repo.repo, commit_oid).expect("Failed to get files changed");
        assert_eq!(result.len(), 2, "Expected two files changed");
        let filenames: Vec<_> = result.iter().map(|path| path.to_str().unwrap()).collect();
        assert!(filenames.contains(&"test1.txt"), "Expected test1.txt to be changed");
        assert!(filenames.contains(&"test2.txt"), "Expected test2.txt to be changed");
    }

    #[test]
    fn test_get_commit_log() {
        let test_repo = TestRepo::new();
        test_repo.add_file("file1.txt", "Hello, world!").expect("Failed to add file");
        test_repo.commit("Add file1.txt").unwrap();
        test_repo.add_file("file2.txt", "Hello, again!").expect("Failed to add file");
        test_repo.commit("Add file2.txt").unwrap();
        let path = test_repo.path();

        let commit_log = revwalk_commit_log(&test_repo.repo, path).unwrap();
        let commits: Vec<_> = commit_log.into_iter().collect();

        assert_eq!(commits.len(), 2);
        assert_eq!(commits[0].commit.message(), "Add file2.txt");
        assert_eq!(commits[1].commit.message(), "Add file1.txt");
    }

    #[rstest]
    #[case::empty_empty("", "", "")]
    #[case::empty_root("", "/root", "/root")]
    #[case::root_empty("/root", "", "")]
    #[case::initial_overlap_extra_project("/root/path", "/root/path/to/file", "to/file")]
    #[case::initial_overlap_extra_root("/root/path/to/file", "/root/path", "../../")]
    #[case::cargo_toml("/root/path", "/root/path/Cargo.toml", "Cargo.toml")]
    fn test_relative_path(#[case] repo_path: &str, #[case] project_path: &str, #[case] expected: &str) {
        let repo_path = Path::new(repo_path);
        let project_path = Path::new(project_path);
        let expected = Path::new(expected);
        let result = compute_relative_path(repo_path, project_path);
        assert_eq!(result, expected);
    }

    #[rstest]
    #[case::empty_rs_patch(TestRepoLanguage::Rust, TestRepoType::Empty, crate::BumpRule::Patch, "")]
    #[case::empty_py_minor(TestRepoLanguage::Python, TestRepoType::Empty, crate::BumpRule::Minor, "")]
    #[case::empty_js_major(TestRepoLanguage::JavaScript, TestRepoType::Empty, crate::BumpRule::Major, "")]
    #[case::single_rs_patch(TestRepoLanguage::Rust, TestRepoType::SingleCommit, crate::BumpRule::Patch, "0.1.0")]
    #[case::single_py_minor(TestRepoLanguage::Python, TestRepoType::SingleCommit, crate::BumpRule::Minor, "0.1.0")]
    #[case::single_js_major(TestRepoLanguage::JavaScript, TestRepoType::SingleCommit, crate::BumpRule::Major, "0.1.0")]
    #[case::multi_rs_patch(TestRepoLanguage::Rust, TestRepoType::MultipleCommits, crate::BumpRule::Patch, "0.1.1")]
    #[case::multi_py_minor(TestRepoLanguage::Python, TestRepoType::MultipleCommits, crate::BumpRule::Minor, "0.2.0")]
    #[case::multi_js_major(TestRepoLanguage::JavaScript, TestRepoType::MultipleCommits, crate::BumpRule::Major, "1.0.0")]
    #[case::branching_rs_patch(TestRepoLanguage::Rust, TestRepoType::BranchedMultipleCommits, crate::BumpRule::Patch, "0.1.1")]
    #[case::branching_py_minor(TestRepoLanguage::Python, TestRepoType::BranchedMultipleCommits, crate::BumpRule::Minor, "0.2.0")]
    #[case::branching_js_major(TestRepoLanguage::JavaScript, TestRepoType::BranchedMultipleCommits, crate::BumpRule::Major, "1.0.0")]

    fn test_version_bumping(#[case] language: TestRepoLanguage, #[case] type_: TestRepoType, #[case] bump_rule: crate::BumpRule, #[case] expected_version: impl AsRef<str>) {
        let test_repo = TestRepo::new();
        let path = test_repo.path().canonicalize().expect("Could not get full path");
        let rules = vec![(crate::CommitType::Chore, crate::BumpRule::Patch), (crate::CommitType::Fix, bump_rule)];
        let project = TestProject::new(path.clone(), &test_repo, language, type_);
        project.build().expect("Failed to init project");
        match type_ {
            TestRepoType::Empty => {
                if let Ok(_changelog) = project.generate_changelog(&rules) {
                    assert!(false, "changelog should fail with empty repo");
                }
            }
            TestRepoType::SingleCommit => {
                let log = project.generate_log_messages(&rules).expect("Could not build repo");
                let log_messages = project.generate_pretty_log_messages(&rules).expect("Could not build repo");
                assert_eq!(log.len(), 1, "{}", "{log_messages}");
                assert_eq!(log.last().expect("Could not find log"), TestProject::FIRST_COMMIT_MESSAGE, "Commit does not match: {log_messages}");
                assert_eq!(project.generate_next_version(&rules).expect("Could not build repo"), expected_version.as_ref(), "{log_messages}");
            }
            TestRepoType::MultipleCommits | TestRepoType::BranchedMultipleCommits => {
                let log = project.generate_log_messages(&rules).expect("Could not build repo");
                let log_messages = project.generate_pretty_log_messages(&rules).expect("Could not build repo");
                assert_eq!(log.len(), 4, "{}", "{log_messages}");
                assert_eq!(log.first().expect("Could not find log"), "fix: use add", "Recent commit does not match: {log_messages}");
                assert_eq!(
                    log.last().expect("Could not find log"),
                    TestProject::FIRST_COMMIT_MESSAGE,
                    "Oldest commit does not match: {log_messages}"
                );
                assert_eq!(project.generate_next_version(&rules).expect("Could not build repo"), expected_version.as_ref(), "{log_messages}");
            }
        }
    }
}
